


## 1. GPU란 무엇인가?

- GPU(Graphics Processing Unit)는 CPU처럼 컴퓨터 안에 있는 칩이지만 역할이 다릅니다. GPU는 대량의 산술 연산을 빠르게 수행하도록 설계되어 **그래픽과 영상 렌더링**을 담당합니다. 초기에는 2D/3D 이미지와 비디오를 그리는 용도로만 사용됐으나, 최근에는 **영상 편집, 고성능 컴퓨팅, 인공지능 작업 등** 다양한 작업에 활용되고 있습니다.
    
- CPU는 복잡한 명령을 순차적으로 처리하는 데 최적화돼 있지만, GPU는 수백~수천 개의 코어를 병렬로 운용하여 그래픽‑관련 계산을 매우 빠르게 처리합니다. 이 덕분에 게임과 딥러닝 같은 대규모 연산을 CPU보다 훨씬 빠르게 수행할 수 있습니다.
    

## 2. 드라이버의 역할

- **장치 드라이버**는 하드웨어와 운영체제(OS) 사이를 연결하는 소프트웨어입니다. 운영체제의 고수준 명령을 하드웨어가 이해할 수 있는 명령으로 변환하는 **통역사** 역할을 하며, 해당 장치가 제대로 동작하도록 돕습니다. 모든 장치는 전용 드라이버를 필요로 하며, 드라이버가 없으면 시스템에서 장치를 인식하지 못하거나 성능이 낮아질 수 있습니다.
    
- **GPU(그래픽 카드) 드라이버**는 운영체제와 그래픽 카드 간의 통신을 관리하여 그래픽 데이터를 GPU로 전달하고, 렌더링과 성능 최적화를 담당합니다. 최신 드라이버를 유지해야 시스템 안정성과 성능을 보장할 수 있습니다.
    

## 3. 엔비디아의 드라이버 종류 – Game Ready vs. Studio

엔비디아는 두 종류의 공식 드라이버를 제공합니다. 둘을 동시에 설치할 필요는 없으며 **하나만 선택하면 됩니다**.

|드라이버 종류|특징 및 용도|
|---|---|
|**Game Ready**|최신 게임 지원과 성능을 중시하는 드라이버입니다. 새 게임 출시나 패치가 있을 때 빠르게 업데이트되므로 최신 게임을 즐기려는 사용자에게 적합합니다. 업데이트가 잦기 때문에 상대적으로 안정성 문제가 발생할 수 있습니다.|
|**Studio**|게임보다는 영상·사진·3D 렌더링·AI 작업 등 **창작 및 전문가용 소프트웨어의 안정성**을 우선시합니다. 게임 준비 드라이버보다 약간 오래된 버전을 기반으로 해 더 많은 테스트를 거쳐 출시되며, 예측 가능한 안정성을 제공합니다. 게임 성능을 크게 낮추지는 않지만 업데이트가 느린 편입니다.|

- **두 드라이버를 동시에 설치할 필요는 없습니다.** GeForce Experience 또는 드라이버 설치 프로그램에서 둘 중 하나를 선택하여 설치하고, 필요에 따라 변경할 수 있습니다. Game Ready 드라이버로도 작업용 소프트웨어가 실행되며, Studio 드라이버로도 대부분의 게임이 정상 동작합니다.
    

## 4. CUDA와 PyTorch를 위해 드라이버가 필요한 이유

- **CUDA**는 엔비디아가 개발한 병렬 컴퓨팅 플랫폼으로, GPU의 계산 능력을 일반 프로그래밍에서 사용할 수 있게 합니다. CUDA는 세 가지 요소로 구성되는데, **CUDA 드라이버**, **CUDA Toolkit**, **CUDA 라이브러리**입니다. 이 중 **CUDA 드라이버**는 **CPU와 GPU 사이에서 데이터를 교환하고, 병렬 실행을 동기화하며, 커널 실행·메모리 관리 등을 담당하는 핵심 컴포넌트**입니다.
    
- **PyTorch 등 딥러닝 프레임워크**는 내부적으로 CUDA 라이브러리를 사용해 GPU에서 연산을 수행합니다. 프레임워크를 설치할 때는 CUDA runtime(라이브러리)와 cuDNN 등을 함께 설치하지만, GPU와 통신하는 **엔비디아 드라이버는 시스템에 설치돼 있어야 합니다.** PyTorch 개발자 포럼에서도 “CUDA‑버전 PyTorch 패키지는 설치할 수 있지만 GPU를 사용하려면 시스템에 CUDA(엔비디아) 드라이버가 있어야 한다”라고 명시하고 있습니다.
    
- PyTorch를 Conda나 pip로 설치할 경우, 프레임워크 안에 CUDA runtime이 포함되어 있기 때문에 별도의 CUDA Toolkit 설치는 필요 없지만, **사용하려는 CUDA runtime 버전을 지원하는 엔비디아 드라이버를 설치해야** 합니다. 개발용으로 커스텀 CUDA 코드를 빌드하려면 추가로 CUDA Toolkit을 설치합니다.
    

### 드라이버가 너무 오래된 경우

PyTorch에서 `torch.cuda.is_available()`을 실행했을 때 GPU를 인식하지 못하는 경우, 보통 엔비디아 드라이버가 너무 오래돼 CUDA runtime과 호환되지 않는 상황입니다. 포럼 사례에서도 “시스템의 NVIDIA 드라이버가 너무 오래되었으니 NVIDIA 웹사이트에서 새 버전을 설치하라”라는 오류 메시지가 나왔습니다. 따라서 GPU를 사용할 때는 **PyTorch에서 요구하는 CUDA 버전을 지원하는 최신 드라이버**를 설치해야 합니다.


### RTX와 GTX, 그리고 “Ti”의 의미

|요소|의미|
|---|---|
|**RTX**|엔비디아의 ‘레이트레이싱(Ray Tracing)’ 전용 하드웨어( **RT 코어**와 **Tensor 코어** )를 포함하는 제품군에 붙는 접두사입니다. 실시간 광선 추적과 AI 가속 기능을 지원하는 고급형 제품이며, 지포스 20 시리즈부터 사용됩니다.|
|**GTX**|16시리즈 이전의 전통적인 지포스 브랜드를 의미합니다. 16 시리즈는 RTX 20 시리즈와 같은 **튜링(Turing) 아키텍처**를 사용하지만 RT 코어와 Tensor 코어가 빠져 있습니다. 그래서 **GTX라는 이름으로 출시됐고, 엔트리~중급형 시장을 목표로 합니다**.|
|**Ti**|“Titanium”의 줄임말로, **같은 숫자의 기본 모델보다 성능을 높인 상위 버전**이라는 뜻입니다. Ti 모델은 CUDA 코어 수와 클록 속도, 메모리 대역폭 등을 늘려 차이가 있으며, 다음 등급 모델과의 중간 다리를 놓는 제품입니다.|

### GTX 1650 Ti는 어떤 GPU인가?

- **중급형 노트북용 GPU** – GTX 1650 Ti는 **전용 노트북 GPU**이며, 데스크톱용 모델은 존재하지 않습니다. TU117 칩을 기반으로 하고, 기본 GTX 1650과 같은 아키텍처지만 **1024개의 셰이더(코어)**를 모두 활성화해 성능을 높였습니다.
    
- **GTX 1650 대비 향상된 사양** – 기본 GTX 1650은 896개의 셰이더와 75 W TGP를 갖지만, GTX 1650 Ti Mobile은 1024개의 셰이더에 50 ~ 80 W의 TGP를 사용합니다. 동일한 TU117 칩을 사용하므로 **레이 트레이싱이나 Tensor 코어는 없습니다**.
    
- **Turing 아키텍처 기반** – RTX 시리즈와 동일한 Turing 아키텍처로 설계돼 **정수·부동소수 연산을 동시에 수행하는 개선된 CUDA 코어**와 **통합 캐시 구조**를 적용했습니다. 덕분에 Pascal 세대 대비 최대 **50% 더 많은 명령을 처리하고 40% 더 효율적**입니다.
    
- **다양한 전력·메모리 구성** – 노트북 제작사를 위해 128비트 50 W, 256비트 55 W 버전을 제공하며, 전력 효율을 높인 **Max‑Q 모델(35 W)** 도 있습니다. 이러한 변형 덕분에 얇고 가벼운 노트북에서도 사용할 수 있습니다.
    
- **주요 용도** – GTX 1650 Ti는 1080p 게이밍과 멀티미디어용 노트북에 적합한 GPU로, RTX 2060 같은 상위 제품보다 저렴합니다. 하지만 **RT 코어나 Tensor 코어가 없기 때문에 하드웨어 기반 레이트레이싱과 AI 가속 기능은 지원하지 않습니다**.



## Compute Capability는 무엇인가


- NVIDIA가 **GPU 세대/아키텍처를 구분하는 버전 번호**입니다.
    
    - 예: Turing(=GTX 16xx/20xx) → **7.5**, Ampere(RTX 30xx) → **8.6**, A100 → **8.0**, Hopper(H100) → **9.0** …
        
- 이 숫자에 따라 **사용 가능한 명령어/하드웨어 기능**(Tensor Core 세대, 연산 최적화, 메모리 특성)이 달라집니다. 새로운 세대일수록 더 많은 기능을 지원하고 성능이 최적화되어 있습니다.

- CUDA 코드는 결국 **GPU용 기계어(=SASS)** 또는 **중간표현(=PTX)** 으로 컴파일돼서 실행되는데,어떤 GPU에서 돌릴지에 따라 **다른 바이너리**가 필요합니다.
  
- 내 카드(예: 7.5)용 바이너리가 **빠져 있으면**, 그 커널을 로드할 때 에러가 터질 수 있습니다.
    `no kernel image is available for execution on the device`

- 컴파일러(`nvcc`)나 PyTorch 빌드가 이 CC 값을 보고 **그 GPU에서 동작 가능한 커널 코드**를 생성합니다. 예를 들어, `8.6` (RTX 30xx 시리즈)로 빌드했는데, 실제 GPU가 `7.5`라면 실행이 안 될 수 있습니다. 반대로 `7.5` 기준으로 빌드하면 RTX 30xx에서도 동작은 하지만, **최신 최적화 기능**을 사용 못합니다.

### 아키텍처별 요약 순위 (최신 → 구세대)

1. **CC 10.0**: GB200/B200
2. **CC 9.0**: H100 시리즈 (Hopper)
3. **CC 8.9**: Ada Lovelace RTX 40‑시리즈
4. **CC 8.6**: Ampere A40/A10 계열
5. **CC 8.0**: Ampere A100
6. **CC 7.5**: Turing GTX 16xx / RTX 20xx / GTX 1650 Ti