
소스 코드에서 시퀀스 값을 저장하는 데 `BigInteger`가 사용되어, 실제로는 `int`로 충분히 처리할 수 있는 상황임에도 불필요하게 복잡한 타입이 사용되고 있었고,
`int`와 `BigInteger` 간의 메모리·성능 비교를 정리하였다. 그 결과를 바탕으로 해당 변수를 `int`(또는 `Integer/long`)로 변경하여 코드를 단순화했다.

---


| 타입                 | 메모리 사용량        | 특징                                                 |
| ------------------ | -------------- | -------------------------------------------------- |
| **`int` (프리미티브)**  | 4바이트           | 스택에 직접 저장, 오버헤드 없음                                 |
| **`Integer` (객체)** | 약 16–24바이트1    | 힙 객체 + 객체 헤더 + 박싱 오버헤드                             |
| **`BigInteger`**   | 약 48–80바이트 이상2 | 가변 길이 `int[]` + 객체 헤더 + `signum` 필드 등 (자릿수에 따라 증가) |

1 객체 헤더(약 12–16B) + `int` 필드(4B) + 패딩  
2 객체 헤더 + `int[]` 참조 + 배열 헤더(약 16B) + 배열 요소(자릿수×4B) + `signum`(4B)

---

### 왜 `BigInteger`가 비효율적인가?

1. **메모리 낭비**
    
    - 시퀀스처럼 작은 범위 정수를 다수 저장할 때, 객체당 수십 바이트가 불필요하게 소모됨
        
2. **GC(가비지 컬렉션) 부하 증가**
    
    - 힙 객체 수가 늘어나면서 GC 작업 빈도·시간이 늘어남
        
3. **연산 비용**
    
    - 내부적으로 배열 순회 연산을 수행하므로 단순 정수 연산(`int`/`long`)보다 느림
        

---

### 추천 방안

- **단일 시퀀스 용도**
    
    - 범위가 충분히 작으면 `int` 또는 여유가 필요하면 `long` 사용
        
- **ORM/JDBC 매핑**
    
    - 자동으로 `BigInteger`를 반환하는 설정이라면, 매퍼(`<resultType>`·핸들러)를 `INTEGER`/`BIGINT`로 변경하여 처음부터 `Integer`/`Long`으로 받기
        

```xml
<!-- MyBatis 예시 -->
<resultMap id="RuleResult" type="com.example.Rule">
  <result property="postfixRuleSeq" column="POSTFIX_RULE_SEQ" jdbcType="INTEGER"/>
</resultMap>
```

이렇게 하면 메모리 절약은 물론 GC 부하와 연산 비용도 크게 줄일 수 있습니다.